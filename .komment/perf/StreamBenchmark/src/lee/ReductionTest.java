{"name":"ReductionTest.java","path":"perf/StreamBenchmark/src/lee/ReductionTest.java","content":{"structured":{"description":"a `ReductionTest` class that contains a `doTest()` method. The `doTest()` method initializes some variables, generates a list of orders, and then loops through the list multiple times using three different methods to calculate the total value of each user's orders. The methods used are `sumOrderForLoop()`, `sumOrderStream()`, and `sumOrderParallelStream()`. Each of these methods takes advantage of a different high-level package: `java.util.stream` for the `sumOrderStream()` method, `java.util.concurrent` for the `sumOrderParallelStream()` method, and `java.util` for the `sumOrderForLoop()` method. The code also defines an `Order` class that represents each order in the list, with fields for the user name, price, and timestamp.","items":[{"id":"a3cb599b-3b67-7099-1e47-2a71149918a9","ancestors":[],"type":"function","description":"is a test class for evaluating the performance of three different methods for summing up the prices of orders in a list, using different programming constructs such as loops, streams, and parallel streams. The test class performs experiments on various lengths of order lists and measures the execution time of each method.","name":"ReductionTest","code":"public class ReductionTest {\n\n\tpublic static void main(String[] args) {\n\t\tnew ReductionTest().doTest();\n\t}\n\tpublic void doTest(){\n\t\twarmUp();\n\t\tint[] lengths = {\n\t\t\t\t10000, \n\t\t\t\t100000, \n\t\t\t\t1000000, \n\t\t\t\t10000000, \n\t\t\t\t20000000, \n\t\t\t\t40000000\n\t\t\t};\n\t\tfor(int length : lengths){\n\t\t\tSystem.out.println(String.format(\"---orders length: %d---\", length));\n\t\t\tList<Order> orders = Order.genOrders(length);\n\t\t\tint times = 4;\n\t\t\tMap<String, Double> map1 = null;\n\t\t\tMap<String, Double> map2 = null;\n\t\t\tMap<String, Double> map3 = null;\n\t\t\t\n\t\t\tlong startTime;\n\t\t\t\n\t\t\tstartTime = System.nanoTime();\n\t\t\tfor(int i=0; i<times; i++){\n\t\t\t\tmap1 = sumOrderForLoop(orders);\n\t\t\t}\n\t\t\tTimeUtil.outTimeUs(startTime, \"sumOrderForLoop time:\", times);\n\t\t\t\n\t\t\tstartTime = System.nanoTime();\n\t\t\tfor(int i=0; i<times; i++){\n\t\t\t\tmap2 = sumOrderStream(orders);\n\t\t\t}\n\t\t\tTimeUtil.outTimeUs(startTime, \"sumOrderStream time:\", times);\n\n\t\t\tstartTime = System.nanoTime();\n\t\t\tfor(int i=0; i<times; i++){\n\t\t\t\tmap3 = sumOrderParallelStream(orders);\t\n\t\t\t}\n\t\t\tTimeUtil.outTimeUs(startTime, \"sumOrderParallelStream time:\", times);\n\t\t\t\n\t\t\tSystem.out.println(\"users=\" + map3.size());\n\t\t\n\t\t}\n\t}\n\tprivate void warmUp(){\n\t\tList<Order> orders = Order.genOrders(10);\n\t\tfor(int i=0; i<20000; i++){\n\t\t\tsumOrderForLoop(orders);\n\t\t\tsumOrderStream(orders);\n\t\t\tsumOrderParallelStream(orders);\n\t\t\t\n\t\t}\n\t}\n\tprivate Map<String, Double> sumOrderForLoop(List<Order> orders){\n\t\tMap<String, Double> map = new HashMap<>();\n\t\tfor(Order od : orders){\n\t\t\tString userName = od.getUserName();\n\t\t\tDouble v; \n\t\t\tif((v=map.get(userName)) != null){\n\t\t\t\tmap.put(userName, v+od.getPrice());\n\t\t\t}else{\n\t\t\t\tmap.put(userName, od.getPrice());\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\tprivate Map<String, Double> sumOrderStream(List<Order> orders){\n\t\treturn orders.stream().collect(\n\t\t\t\tCollectors.groupingBy(Order::getUserName, \n\t\t\t\t\t\tCollectors.summingDouble(Order::getPrice)));\n\t}\n\tprivate Map<String, Double> sumOrderParallelStream(List<Order> orders){\n\t\treturn orders.parallelStream().collect(\n\t\t\t\tCollectors.groupingBy(Order::getUserName, \n\t\t\t\t\t\tCollectors.summingDouble(Order::getPrice)));\n\t}\n}","location":{"start":17,"insert":11,"offset":" ","indent":0,"comment":{"start":10,"end":16}},"item_type":"class","length":80,"docLength":6},{"id":"4e0a46c2-972e-e09c-b847-343a2bc962fc","ancestors":["a3cb599b-3b67-7099-1e47-2a71149918a9"],"type":"function","description":"runs a test for reduction.","params":[{"name":"args","type_name":"String[]","description":"1 or more command line arguments passed to the `main` function when the program is executed.\n\n* Length: The `args` array has 0 or more elements, depending on how many command-line arguments were passed to the program.\n* Elements: Each element in `args` is a String representing a command-line argument.\n* Type: The type of each element in `args` is String.","complex_type":true}],"name":"main","code":"public static void main(String[] args) {\n\t\tnew ReductionTest().doTest();\n\t}","location":{"start":19,"insert":19,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null},{"id":"96baf351-9f66-35b0-3e4d-19565191131f","ancestors":["a3cb599b-3b67-7099-1e47-2a71149918a9"],"type":"function","description":"generates and sums orders using different loops, streams, and parallel streams, measuring the time complexity for each approach.","params":[],"usage":{"language":"java","code":"public class Main {\n  public static void main(String[] args) {\n    new OrderExample().doTest();\n  }\n}\n","description":"\nExplanation:\n\n* The method doTest() calls the method warmUp(), which initializes a list of 10,000 orders.\n* Then it loops through five different lengths for the list of orders in order to demonstrate the execution time differences between three methods using streams and parallel streams to calculate the sum of prices for each user:\n\t+ Methods using for-loops to iterate over the list of orders and collect the sums into a map with Streams and parallel streams.\n\t+ The code will then print out the execution time and the number of users in the map.\n\nPlease note that the order of execution time is not guaranteed, so it may change from one run to another."},"name":"doTest","code":"public void doTest(){\n\t\twarmUp();\n\t\tint[] lengths = {\n\t\t\t\t10000, \n\t\t\t\t100000, \n\t\t\t\t1000000, \n\t\t\t\t10000000, \n\t\t\t\t20000000, \n\t\t\t\t40000000\n\t\t\t};\n\t\tfor(int length : lengths){\n\t\t\tSystem.out.println(String.format(\"---orders length: %d---\", length));\n\t\t\tList<Order> orders = Order.genOrders(length);\n\t\t\tint times = 4;\n\t\t\tMap<String, Double> map1 = null;\n\t\t\tMap<String, Double> map2 = null;\n\t\t\tMap<String, Double> map3 = null;\n\t\t\t\n\t\t\tlong startTime;\n\t\t\t\n\t\t\tstartTime = System.nanoTime();\n\t\t\tfor(int i=0; i<times; i++){\n\t\t\t\tmap1 = sumOrderForLoop(orders);\n\t\t\t}\n\t\t\tTimeUtil.outTimeUs(startTime, \"sumOrderForLoop time:\", times);\n\t\t\t\n\t\t\tstartTime = System.nanoTime();\n\t\t\tfor(int i=0; i<times; i++){\n\t\t\t\tmap2 = sumOrderStream(orders);\n\t\t\t}\n\t\t\tTimeUtil.outTimeUs(startTime, \"sumOrderStream time:\", times);\n\n\t\t\tstartTime = System.nanoTime();\n\t\t\tfor(int i=0; i<times; i++){\n\t\t\t\tmap3 = sumOrderParallelStream(orders);\t\n\t\t\t}\n\t\t\tTimeUtil.outTimeUs(startTime, \"sumOrderParallelStream time:\", times);\n\t\t\t\n\t\t\tSystem.out.println(\"users=\" + map3.size());\n\t\t\n\t\t}\n\t}","location":{"start":22,"insert":22,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":42,"docLength":null},{"id":"951c580a-b656-958b-5249-7b19955d5846","ancestors":["a3cb599b-3b67-7099-1e47-2a71149918a9"],"type":"function","description":"generates and processes 10 orders using three different methods: `sumOrderForLoop`, `sumOrderStream`, and `sumOrderParallelStream`.","params":[],"usage":{"language":"java","code":"public static void main(String[] args) {\n\tReductionTest test = new ReductionTest();\n\ttest.warmUp();\n}\n","description":""},"name":"warmUp","code":"private void warmUp(){\n\t\tList<Order> orders = Order.genOrders(10);\n\t\tfor(int i=0; i<20000; i++){\n\t\t\tsumOrderForLoop(orders);\n\t\t\tsumOrderStream(orders);\n\t\t\tsumOrderParallelStream(orders);\n\t\t\t\n\t\t}\n\t}","location":{"start":64,"insert":64,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":9,"docLength":null},{"id":"83373d20-a93f-eeac-9147-cc1dfd0faf3b","ancestors":["a3cb599b-3b67-7099-1e47-2a71149918a9"],"type":"function","description":"takes a list of orders as input and creates a map containing the total price of each order for a specific user.","params":[{"name":"orders","type_name":"List<Order>","description":"list of orders that are to be summed and mapped.\n\n* `List<Order>` represents an ordered list of `Order` objects.\n* Each `Order` object has the following attributes:\n\t+ `UserName`: a string representing the user name associated with the order.\n\t+ `Price`: a double value representing the price of the order.","complex_type":true}],"returns":{"type_name":"Map","description":"a `Map` object containing the total amount spent by each user in a list of orders.\n\n* The map contains key-value pairs representing the total cost of orders for each user.\n* Each key in the map is a unique user name, and the corresponding value is the total cost of orders for that user.\n* If a user has no orders, the value associated with their key is `0`.\n* The map is a mutable object, meaning it can be modified by adding or updating values.","complex_type":true},"usage":{"language":"java","code":"public static void main(String[] args) {\n\t// create a List<Order> with 100 elements\n\tList<Order> orders = Order.genOrders(100);\n\t// print the Map<String, Double> created by sumOrderForLoop() method\n\tSystem.out.println(\"Map from sumOrderForLoop(): \" + sumOrderForLoop(orders));\n}\n","description":""},"name":"sumOrderForLoop","code":"private Map<String, Double> sumOrderForLoop(List<Order> orders){\n\t\tMap<String, Double> map = new HashMap<>();\n\t\tfor(Order od : orders){\n\t\t\tString userName = od.getUserName();\n\t\t\tDouble v; \n\t\t\tif((v=map.get(userName)) != null){\n\t\t\t\tmap.put(userName, v+od.getPrice());\n\t\t\t}else{\n\t\t\t\tmap.put(userName, od.getPrice());\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}","location":{"start":73,"insert":73,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":13,"docLength":null},{"id":"1121869c-90a7-248e-2840-c7434d6a1485","ancestors":["a3cb599b-3b67-7099-1e47-2a71149918a9"],"type":"function","description":"aggregates the prices of orders based on the user name, and returns a map of user names to total price amounts.","params":[{"name":"orders","type_name":"List<Order>","description":"list of orders that are being summarized by the function.\n\n* `List<Order>`: A list of `Order` objects representing orders to be summed.\n* `Order`: An object with attributes `getUserName()` and `getPrice()`, which return a user name and a double value, respectively.","complex_type":true}],"returns":{"type_name":"Map","description":"a map of user names to the total price of orders placed by each user.\n\nThe output is a `Map` containing `String`, `Double` keys and values. This indicates that the orders are grouped by user name, and the total price of each order is calculated and stored in the map as a double value.","complex_type":true},"usage":{"language":"java","code":"List<Order> orders = Order.genOrders(10); //Generate a list of 10 Orders for testing purposes\nMap<String, Double> orderPriceSum = sumOrderStream(orders); //Pass the list to the collect method\n//Print the results of the calculation\nSystem.out.println(\"Orders' prices are: \" + orderPriceSum);\n","description":""},"name":"sumOrderStream","code":"private Map<String, Double> sumOrderStream(List<Order> orders){\n\t\treturn orders.stream().collect(\n\t\t\t\tCollectors.groupingBy(Order::getUserName, \n\t\t\t\t\t\tCollectors.summingDouble(Order::getPrice)));\n\t}","location":{"start":86,"insert":86,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":5,"docLength":null},{"id":"cdcb8b06-95ab-018b-db43-8a5135ed82db","ancestors":["a3cb599b-3b67-7099-1e47-2a71149918a9"],"type":"function","description":"takes a list of orders and returns a map with the user name as key and the total price of orders placed by each user as value, calculated by summing the prices of the orders for each user in parallel stream.","params":[{"name":"orders","type_name":"List<Order>","description":"list of orders to be summed.\n\n* `List<Order>` - The function takes a list of orders as input. Each order has multiple attributes like `getUserName`, `getPrice`.\n* `parallelStream()` - This method applies the `Collectors.groupingBy()` and `Collectors.summingDouble()` methods in parallel, leveraging the efficiency of Java 8 stream API.","complex_type":true}],"returns":{"type_name":"Map","description":"a map of user names to sum of prices for each user.\n\n* The output is a map data structure where each key is a string representing the user name of an order, and each value is a double number representing the total price of all orders placed by that user.\n* The map is generated using the `collect` method of the `parallelStream` API, which takes two functions as arguments: `Collectors.groupingBy(Order::getUserName)` to group the orders by user name, and `Collectors.summingDouble(Order::getPrice)` to calculate the total price for each user.\n* The `parallelStream` method is used to execute the stream of orders in parallel, which improves performance when processing large amounts of data.","complex_type":true},"usage":{"language":"java","code":"List<Order> orders = Order.genOrders(10);\nMap<String, Double> map = ReductionTest.sumOrderParallelStream(orders);\n","description":""},"name":"sumOrderParallelStream","code":"private Map<String, Double> sumOrderParallelStream(List<Order> orders){\n\t\treturn orders.parallelStream().collect(\n\t\t\t\tCollectors.groupingBy(Order::getUserName, \n\t\t\t\t\t\tCollectors.summingDouble(Order::getPrice)));\n\t}","location":{"start":91,"insert":91,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":5,"docLength":null},{"id":"8321b86f-b3f1-a285-c44d-9a5bb8b350c0","ancestors":[],"type":"function","description":"is used to represent an order in a system, with attributes for user name, price, and timestamp. The genOrders method generates a list of orders randomly, with the number of orders per user and the total number of orders controlled by the user. The toString method provides a concise representation of an order as a string.","name":"Order","code":"class Order{\n\tprivate String userName;\n\tprivate double price;\n\tprivate long timestamp;\n\tpublic Order(String userName, double price, long timestamp) {\n\t\tthis.userName = userName;\n\t\tthis.price = price;\n\t\tthis.timestamp = timestamp;\n\t}\n\tpublic String getUserName() {\n\t\treturn userName;\n\t}\n\tpublic double getPrice() {\n\t\treturn price;\n\t}\n\tpublic long getTimestamp() {\n\t\treturn timestamp;\n\t}\n\tpublic static List<Order> genOrders(int listLength){\n\t\tArrayList<Order> list = new ArrayList<>(listLength);\n\t\tRandom rand = new Random();\n\t\tint users = listLength/200;// 200 orders per user\n\t\tusers = users==0 ? listLength : users;\n\t\tArrayList<String> userNames = new ArrayList<>(users);\n\t\tfor(int i=0; i<users; i++){\n\t\t\tuserNames.add(UUID.randomUUID().toString());\n\t\t}\n\t\tfor(int i=0; i<listLength; i++){\n\t\t\tdouble price = rand.nextInt(1000);\n\t\t\tString userName = userNames.get(rand.nextInt(users));\n\t\t\tlist.add(new Order(userName, price, System.nanoTime()));\n\t\t}\n\t\treturn list;\n\t}\n\t@Override\n\tpublic String toString(){\n\t\treturn userName + \"::\" + price;\n\t}\n}","location":{"start":97,"insert":97,"offset":" ","indent":0,"comment":null},"item_type":"class","length":39,"docLength":null},{"id":"be86d94d-8197-e88b-7e4b-075119dc6482","ancestors":["8321b86f-b3f1-a285-c44d-9a5bb8b350c0"],"type":"function","description":"retrieves a user's username.","params":[],"returns":{"type_name":"String","description":"a string representing the user's name.","complex_type":false},"usage":{"language":"java","code":"public class Main{\n    public static void main(String[] args){\n        Order order = new Order(\"username\", 10, 50);\n        System.out.println(order.getUserName()); //outputs \"username\"\n    }\n}\n","description":""},"name":"getUserName","code":"public String getUserName() {\n\t\treturn userName;\n\t}","location":{"start":106,"insert":106,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null},{"id":"f52e05d1-4ab7-dcb1-c046-784995aba030","ancestors":["8321b86f-b3f1-a285-c44d-9a5bb8b350c0"],"type":"function","description":"Retrieves the price value.","params":[],"returns":{"type_name":"double","description":"the current price of the item.","complex_type":false},"usage":{"language":"java","code":"public class OrderTest {\n\tpublic static void main(String[] args) {\n\t\tOrder order = new Order(\"John\", 50, System.currentTimeMillis());\n\t\tSystem.out.println(\"The price of the order is \" + order.getPrice());\n\t}\n}\n","description":""},"name":"getPrice","code":"public double getPrice() {\n\t\treturn price;\n\t}","location":{"start":109,"insert":109,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null},{"id":"3d61b3d7-0492-dc9e-c64b-cec77d8c4779","ancestors":["8321b86f-b3f1-a285-c44d-9a5bb8b350c0"],"type":"function","description":"retrieves the `timestamp` variable, which represents a system-specific timestamp value.","params":[],"returns":{"type_name":"long","description":"a long value representing the current timestamp.","complex_type":false},"usage":{"language":"java","code":"long timeStamp = order.getTimeStamp();\n","description":"\nThis would return the timestamp value stored within the Order object."},"name":"getTimestamp","code":"public long getTimestamp() {\n\t\treturn timestamp;\n\t}","location":{"start":112,"insert":112,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null},{"id":"74802269-48df-0184-234f-9761e240c1d4","ancestors":["8321b86f-b3f1-a285-c44d-9a5bb8b350c0"],"type":"function","description":"generates a list of `Order` objects with varying prices and user names, simulating orders placed by multiple users.","params":[{"name":"listLength","type_name":"int","description":"total number of orders to be generated in the function, and it is used to determine the number of users and the size of each user's order list.","complex_type":false}],"returns":{"type_name":"ArrayList","description":"a list of `Order` objects containing random user names, prices, and timestamps.\n\n* The list is of type `List<Order>`, indicating that it is a collection of Order objects.\n* The list contains `listLength` elements, where `listLength` is the input parameter passed to the function.\n* Each element in the list is an instance of Order, representing a single order generated randomly.\n* The Order objects contain three attributes: user name, price, and timestamp, which are generated randomly using `Random` instances.\n* The user name is a unique identifier generated using `UUID.randomUUID()`, ensuring that each order has a distinct user name.\n* The price of each order is generated randomly between 0 and 1000, representing the random cost of the order.\n* The timestamp is generated using `System.nanoTime()` and represents the time at which the order was generated.","complex_type":true},"name":"genOrders","code":"public static List<Order> genOrders(int listLength){\n\t\tArrayList<Order> list = new ArrayList<>(listLength);\n\t\tRandom rand = new Random();\n\t\tint users = listLength/200;// 200 orders per user\n\t\tusers = users==0 ? listLength : users;\n\t\tArrayList<String> userNames = new ArrayList<>(users);\n\t\tfor(int i=0; i<users; i++){\n\t\t\tuserNames.add(UUID.randomUUID().toString());\n\t\t}\n\t\tfor(int i=0; i<listLength; i++){\n\t\t\tdouble price = rand.nextInt(1000);\n\t\t\tString userName = userNames.get(rand.nextInt(users));\n\t\t\tlist.add(new Order(userName, price, System.nanoTime()));\n\t\t}\n\t\treturn list;\n\t}","location":{"start":115,"insert":115,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":16,"docLength":null},{"id":"b8c92111-bd86-f692-9f42-19c4306ec3a6","ancestors":["8321b86f-b3f1-a285-c44d-9a5bb8b350c0"],"type":"function","description":"generates a string representation of an object by combining its user name and price.","params":[],"returns":{"type_name":"String","description":"a concatenation of the user name and price.","complex_type":false},"usage":{"language":"java","code":"public class Order {\n    private String userName;\n    private double price;\n    public Order(String userName, double price) {\n        this.userName = userName;\n        this.price = price;\n    }\n    @Override\n    public String toString() {\n        return userName + \"::\" + price;\n    }\n}\n","description":"\nThis code creates an Order class with a constructor that takes two parameters, user name and price. The class has an override of the toString method which returns a string representation of the object in the format of `\"userName::price\"`. This can be used for debugging purposes as well as for logging purposes."},"name":"toString","code":"@Override\n\tpublic String toString(){\n\t\treturn userName + \"::\" + price;\n\t}","location":{"start":131,"insert":131,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":4,"docLength":null}]}}}