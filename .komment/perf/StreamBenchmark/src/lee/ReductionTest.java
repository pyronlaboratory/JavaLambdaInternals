{"name":"ReductionTest.java","path":"perf/StreamBenchmark/src/lee/ReductionTest.java","content":{"structured":{"description":"a `ReductionTest` class that contains a `main()` method for running the program and several other methods for testing purposes. The code uses various packages such as `java.util`, `java.lang`, `java.io`, and `java.security`. The main method calls the `doTest()` method, which performs multiple iterations of summing up order data using different approaches, including a for-loop, a stream-based approach, and a parallel stream-based approach. Each iteration generates a list of orders and sums up the prices of the orders for each user. The program also includes a `warmUp()` method that simulates running the `sumOrderForLoop()`, `sumOrderStream()`, and `sumOrderParallelStream()` methods multiple times to speed up the computation. Overall, the code performs aggregation calculations on large datasets using different approaches to measure the performance of each approach.","items":[{"id":"905b1415-5d99-89a3-a34c-f984d63eee91","ancestors":[],"type":"function","description":"is a Java file that tests various ways of summing up orders based on their prices. The main method calls the `doTest()` method, which performs the testing. The tester generates different lengths of order lists and runs the summing methods multiple times for each list length. The methods tested include `sumOrderForLoop`, `sumOrderStream`, and `sumOrderParallelStream`. Each method is called on a list of orders and returns a map with the total price of each user's orders. The tester also includes some warm-up code to ensure the methods are properly initialized before running the tests.","name":"ReductionTest","code":"public class ReductionTest {\n\n\tpublic static void main(String[] args) {\n\t\tnew ReductionTest().doTest();\n\t}\n\tpublic void doTest(){\n\t\twarmUp();\n\t\tint[] lengths = {\n\t\t\t\t10000, \n\t\t\t\t100000, \n\t\t\t\t1000000, \n\t\t\t\t10000000, \n\t\t\t\t20000000, \n\t\t\t\t40000000\n\t\t\t};\n\t\tfor(int length : lengths){\n\t\t\tSystem.out.println(String.format(\"---orders length: %d---\", length));\n\t\t\tList<Order> orders = Order.genOrders(length);\n\t\t\tint times = 4;\n\t\t\tMap<String, Double> map1 = null;\n\t\t\tMap<String, Double> map2 = null;\n\t\t\tMap<String, Double> map3 = null;\n\t\t\t\n\t\t\tlong startTime;\n\t\t\t\n\t\t\tstartTime = System.nanoTime();\n\t\t\tfor(int i=0; i<times; i++){\n\t\t\t\tmap1 = sumOrderForLoop(orders);\n\t\t\t}\n\t\t\tTimeUtil.outTimeUs(startTime, \"sumOrderForLoop time:\", times);\n\t\t\t\n\t\t\tstartTime = System.nanoTime();\n\t\t\tfor(int i=0; i<times; i++){\n\t\t\t\tmap2 = sumOrderStream(orders);\n\t\t\t}\n\t\t\tTimeUtil.outTimeUs(startTime, \"sumOrderStream time:\", times);\n\n\t\t\tstartTime = System.nanoTime();\n\t\t\tfor(int i=0; i<times; i++){\n\t\t\t\tmap3 = sumOrderParallelStream(orders);\t\n\t\t\t}\n\t\t\tTimeUtil.outTimeUs(startTime, \"sumOrderParallelStream time:\", times);\n\t\t\t\n\t\t\tSystem.out.println(\"users=\" + map3.size());\n\t\t\n\t\t}\n\t}\n\tprivate void warmUp(){\n\t\tList<Order> orders = Order.genOrders(10);\n\t\tfor(int i=0; i<20000; i++){\n\t\t\tsumOrderForLoop(orders);\n\t\t\tsumOrderStream(orders);\n\t\t\tsumOrderParallelStream(orders);\n\t\t\t\n\t\t}\n\t}\n\tprivate Map<String, Double> sumOrderForLoop(List<Order> orders){\n\t\tMap<String, Double> map = new HashMap<>();\n\t\tfor(Order od : orders){\n\t\t\tString userName = od.getUserName();\n\t\t\tDouble v; \n\t\t\tif((v=map.get(userName)) != null){\n\t\t\t\tmap.put(userName, v+od.getPrice());\n\t\t\t}else{\n\t\t\t\tmap.put(userName, od.getPrice());\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\tprivate Map<String, Double> sumOrderStream(List<Order> orders){\n\t\treturn orders.stream().collect(\n\t\t\t\tCollectors.groupingBy(Order::getUserName, \n\t\t\t\t\t\tCollectors.summingDouble(Order::getPrice)));\n\t}\n\tprivate Map<String, Double> sumOrderParallelStream(List<Order> orders){\n\t\treturn orders.parallelStream().collect(\n\t\t\t\tCollectors.groupingBy(Order::getUserName, \n\t\t\t\t\t\tCollectors.summingDouble(Order::getPrice)));\n\t}\n}","location":{"start":17,"insert":11,"offset":" ","indent":0,"comment":{"start":10,"end":16}},"item_type":"class","length":80,"docLength":6},{"id":"64d5cb27-1e84-2cbc-3d49-56159d26916c","ancestors":["905b1415-5d99-89a3-a34c-f984d63eee91"],"type":"function","description":"calls the `doTest()` method, which performs some operation.","params":[{"name":"args","type_name":"String[]","description":"1 or more command line arguments passed to the `main` method when the program is run directly from the command line.\n\n* The function takes an array of strings as input, denoted by `String[] args`.\n* The length of the array is not fixed and can vary depending on the invocation of the program.\n* Each element in the array represents a command-line argument passed to the program during execution.","complex_type":true}],"name":"main","code":"public static void main(String[] args) {\n\t\tnew ReductionTest().doTest();\n\t}","location":{"start":19,"insert":19,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null},{"id":"5c168e18-a3a4-8aa5-b146-4567a8718aef","ancestors":["905b1415-5d99-89a3-a34c-f984d63eee91"],"type":"function","description":"performs a series of tests on a list of orders, including generating orders using different methods, summing them using loops and stream APIs, and measuring the execution time of each method.","params":[],"usage":{"language":"java","code":"public class OrderFinder {\n    public static void main(String[] args) {\n        // Instantiate an OrderFinder object\n        OrderFinder finder = new OrderFinder();\n        \n        // Call the doTest() method on the finder object\n        finder.doTest();\n    }\n}\n","description":"\nThis would call the doTest() method of the OrderFinder class, which would then proceed to test the code within the method."},"name":"doTest","code":"public void doTest(){\n\t\twarmUp();\n\t\tint[] lengths = {\n\t\t\t\t10000, \n\t\t\t\t100000, \n\t\t\t\t1000000, \n\t\t\t\t10000000, \n\t\t\t\t20000000, \n\t\t\t\t40000000\n\t\t\t};\n\t\tfor(int length : lengths){\n\t\t\tSystem.out.println(String.format(\"---orders length: %d---\", length));\n\t\t\tList<Order> orders = Order.genOrders(length);\n\t\t\tint times = 4;\n\t\t\tMap<String, Double> map1 = null;\n\t\t\tMap<String, Double> map2 = null;\n\t\t\tMap<String, Double> map3 = null;\n\t\t\t\n\t\t\tlong startTime;\n\t\t\t\n\t\t\tstartTime = System.nanoTime();\n\t\t\tfor(int i=0; i<times; i++){\n\t\t\t\tmap1 = sumOrderForLoop(orders);\n\t\t\t}\n\t\t\tTimeUtil.outTimeUs(startTime, \"sumOrderForLoop time:\", times);\n\t\t\t\n\t\t\tstartTime = System.nanoTime();\n\t\t\tfor(int i=0; i<times; i++){\n\t\t\t\tmap2 = sumOrderStream(orders);\n\t\t\t}\n\t\t\tTimeUtil.outTimeUs(startTime, \"sumOrderStream time:\", times);\n\n\t\t\tstartTime = System.nanoTime();\n\t\t\tfor(int i=0; i<times; i++){\n\t\t\t\tmap3 = sumOrderParallelStream(orders);\t\n\t\t\t}\n\t\t\tTimeUtil.outTimeUs(startTime, \"sumOrderParallelStream time:\", times);\n\t\t\t\n\t\t\tSystem.out.println(\"users=\" + map3.size());\n\t\t\n\t\t}\n\t}","location":{"start":22,"insert":22,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":42,"docLength":null},{"id":"1a481b34-c726-3196-bd4e-61bff025af8d","ancestors":["905b1415-5d99-89a3-a34c-f984d63eee91"],"type":"function","description":"executes multiple iterations of three different methods for summing a list of orders: `sumOrderForLoop`, `sumOrderStream`, and `sumOrderParallelStream`.","params":[],"usage":{"language":"java","code":"private void warmUp(){\n\t\tList<Order> orders = Order.genOrders(10);\n\t\tfor(int i=0; i<20000; i++){\n\t\t\tsumOrderForLoop(orders);\n\t\t\tsumOrderStream(orders);\n\t\t\tsumOrderParallelStream(orders);\n\t\t}\n\t}\n","description":""},"name":"warmUp","code":"private void warmUp(){\n\t\tList<Order> orders = Order.genOrders(10);\n\t\tfor(int i=0; i<20000; i++){\n\t\t\tsumOrderForLoop(orders);\n\t\t\tsumOrderStream(orders);\n\t\t\tsumOrderParallelStream(orders);\n\t\t\t\n\t\t}\n\t}","location":{"start":64,"insert":64,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":9,"docLength":null},{"id":"a19dbdd9-40bc-ba94-3545-1393c168ffd3","ancestors":["905b1415-5d99-89a3-a34c-f984d63eee91"],"type":"function","description":"maps a list of orders to a map of user names to total order prices by iterating through the list, retrieving and updating the user name to price value in the map for each order.","params":[{"name":"orders","type_name":"List<Order>","description":"list of orders that are being summed and mapped to create a new map.\n\n* `List<Order>` represents an ordered list of `Order` objects.\n* Each `Order` object contains attributes such as `getUserName()` for retrieving the user name and `getPrice()` for retrieving the price.\n\nThe function performs operations on each `Order` in the list, updating a map with the user name and the total cost for that user. If the map already contains a value for the user name, it updates the existing value by adding the price of the current `Order`. Otherwise, it initializes the map with the user name and its corresponding total cost. Finally, the function returns the updated map.","complex_type":true}],"returns":{"type_name":"MapString","description":"a map of user names to their total order value.\n\n* The returned value is a `Map` object containing key-value pairs, where the keys are user names and the values are the total amounts spent by each user.\n* The map is constructed using a `for` loop that iterates over the elements in the `orders` list.\n* For each element in the `orders` list, the function checks if the corresponding user name exists in the map. If it does, the function updates the value for that user name by adding the order's price to the existing total amount. If it doesn't exist, the function simply adds the order's price to the map with the user name as the key.\n* The returned map has a size of `orders.size()` since each element in the list is accounted for in the map.","complex_type":true},"usage":{"language":"java","code":"public static void main(String[] args) {\n\t\tList<Order> orders = Order.genOrders(10);\n\t\tMap<String, Double> map = new ReductionTest().sumOrderForLoop(orders);\n\t}\n","description":""},"name":"sumOrderForLoop","code":"private Map<String, Double> sumOrderForLoop(List<Order> orders){\n\t\tMap<String, Double> map = new HashMap<>();\n\t\tfor(Order od : orders){\n\t\t\tString userName = od.getUserName();\n\t\t\tDouble v; \n\t\t\tif((v=map.get(userName)) != null){\n\t\t\t\tmap.put(userName, v+od.getPrice());\n\t\t\t}else{\n\t\t\t\tmap.put(userName, od.getPrice());\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}","location":{"start":73,"insert":73,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":13,"docLength":null},{"id":"bd7c6c47-07e0-e39c-f345-d1d7d3e69bb0","ancestors":["905b1415-5d99-89a3-a34c-f984d63eee91"],"type":"function","description":"aggregates the orders by the user name and calculates the total price for each user.","params":[{"name":"orders","type_name":"List<Order>","description":"list of orders that are to be summed and grouped by user name.\n\n* The `List<Order>` type indicates that the function takes a list of order objects as input.\n* Each `Order` object in the list has a `getUserName()` method that returns a string representing the user name of the order.\n* The `getPrice()` method returns a double value representing the price of the order.\n\nThe function then uses the `stream().collect()` method to group the orders by user name and calculate the total price for each user. The `Collectors` class is used to specify the types of the input streams and the aggregation operation (in this case, grouping and summing).","complex_type":true}],"returns":{"type_name":"MapString","description":"a map containing the sum of the prices of orders for each user.\n\nThe output is a map whose key is a `String` representing the user name of each order, and the value is a `Double` representing the total price of all orders associated with that user name. The map is constructed by grouping the orders by user name using `Collectors.groupingBy`, and then summing the prices of all orders within each group using `Collectors.summingDouble`.","complex_type":true},"usage":{"language":"java","code":"import java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Order> orders = new ArrayList<>();\n        Order order1 = new Order(\"User1\", 20, System.currentTimeMillis());\n        Order order2 = new Order(\"User2\", 40, System.currentTimeMillis());\n        orders.add(order1);\n        orders.add(order2);\n        Map<String, Double> sumOrderStreamOutput = sumOrderStream(orders);\n    }\n\n    private static Map<String, Double> sumOrderStream(List<Order> orders) {\n        return orders.stream().collect(Collectors.groupingBy(Order::getUserName, Collectors.summingDouble(Order::getPrice)));\n    }\n}\n","description":""},"name":"sumOrderStream","code":"private Map<String, Double> sumOrderStream(List<Order> orders){\n\t\treturn orders.stream().collect(\n\t\t\t\tCollectors.groupingBy(Order::getUserName, \n\t\t\t\t\t\tCollectors.summingDouble(Order::getPrice)));\n\t}","location":{"start":86,"insert":86,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":5,"docLength":null},{"id":"dda40a1b-384f-a496-e644-1085bf06de4b","ancestors":["905b1415-5d99-89a3-a34c-f984d63eee91"],"type":"function","description":"collects the prices of orders in a list and groups them by the user name, summing the prices for each user.","params":[{"name":"orders","type_name":"List<Order>","description":"list of orders that will be processed in parallel using the `parallelStream()` method to calculate the total price of each order based on the user name and sum the results.\n\nThe `List<Order>` object contains multiple instances of the `Order` class, which has two attributes - `getUserName()` and `getPrice()`. The `getUserName()` attribute returns a string representing the user name of the order, while the `getPrice()` attribute returns a double value representing the price of the order.","complex_type":true}],"returns":{"type_name":"MapString","description":"a map of user names to total prices summed from the parallel stream of orders.\n\n* The output is a map data structure consisting of key-value pairs, where the keys are Strings and the values are Double values.\n* The map contains entries corresponding to each order in the input list, with the key being the user name of the order and the value being the sum of the prices of all orders belonging to that user.\n* The output is generated using the `collect` method of the `parallelStream` instance, which applies a collector function to the elements of the stream and aggregates them into a single result. In this case, the collector function is a custom implementation that groups the orders by user name and sums the prices of all orders belonging to each user.","complex_type":true},"usage":{"language":"java","code":"List<Order> orders = Order.genOrders(10);\nMap<String, Double> map3 = ReductionTest.sumOrderParallelStream(orders);\nSystem.out.println(\"users=\" + map3.size());\n","description":"\nThe example uses the method sumOrderParallelStream() from the class ReductionTest to create a Map object that contains user names as keys and their corresponding prices as values, calculated based on a list of Order objects passed in as an argument."},"name":"sumOrderParallelStream","code":"private Map<String, Double> sumOrderParallelStream(List<Order> orders){\n\t\treturn orders.parallelStream().collect(\n\t\t\t\tCollectors.groupingBy(Order::getUserName, \n\t\t\t\t\t\tCollectors.summingDouble(Order::getPrice)));\n\t}","location":{"start":91,"insert":91,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":5,"docLength":null},{"id":"c81f6a40-d51c-0c8d-7948-dee480df477e","ancestors":[],"type":"function","description":"has several methods for generating and manipulating orders. These include:\n\n* `genOrders()`: Generates a list of orders with random user names, prices, and timestamps.\n* `toString()`: Returns a string representation of an order in the format \"user name::price\".","name":"Order","code":"class Order{\n\tprivate String userName;\n\tprivate double price;\n\tprivate long timestamp;\n\tpublic Order(String userName, double price, long timestamp) {\n\t\tthis.userName = userName;\n\t\tthis.price = price;\n\t\tthis.timestamp = timestamp;\n\t}\n\tpublic String getUserName() {\n\t\treturn userName;\n\t}\n\tpublic double getPrice() {\n\t\treturn price;\n\t}\n\tpublic long getTimestamp() {\n\t\treturn timestamp;\n\t}\n\tpublic static List<Order> genOrders(int listLength){\n\t\tArrayList<Order> list = new ArrayList<>(listLength);\n\t\tRandom rand = new Random();\n\t\tint users = listLength/200;// 200 orders per user\n\t\tusers = users==0 ? listLength : users;\n\t\tArrayList<String> userNames = new ArrayList<>(users);\n\t\tfor(int i=0; i<users; i++){\n\t\t\tuserNames.add(UUID.randomUUID().toString());\n\t\t}\n\t\tfor(int i=0; i<listLength; i++){\n\t\t\tdouble price = rand.nextInt(1000);\n\t\t\tString userName = userNames.get(rand.nextInt(users));\n\t\t\tlist.add(new Order(userName, price, System.nanoTime()));\n\t\t}\n\t\treturn list;\n\t}\n\t@Override\n\tpublic String toString(){\n\t\treturn userName + \"::\" + price;\n\t}\n}","location":{"start":97,"insert":97,"offset":" ","indent":0,"comment":null},"item_type":"class","length":39,"docLength":null},{"id":"595038f2-cecd-e7a1-5443-9fa180aabcca","ancestors":["c81f6a40-d51c-0c8d-7948-dee480df477e"],"type":"function","description":"returns a string representing the user's name.","params":[],"returns":{"type_name":"String","description":"a string representing the user's name.","complex_type":false},"usage":{"language":"java","code":"public class MyClass {\n    public static void main(String[] args) {\n        Order order = new Order(\"John\", 10, 123456789); // create an instance of the Order class\n        String userName = order.getUserName();          // get the username using the method\n        System.out.println(userName);                  // print the username to the console\n    }\n}\n","description":""},"name":"getUserName","code":"public String getUserName() {\n\t\treturn userName;\n\t}","location":{"start":106,"insert":106,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null},{"id":"9ef1891e-2671-bebd-204b-23d5233d60f3","ancestors":["c81f6a40-d51c-0c8d-7948-dee480df477e"],"type":"function","description":"returns the `price` attribute value.","params":[],"returns":{"type_name":"double","description":"the value of the `price` field.","complex_type":false},"usage":{"language":"java","code":"//Example usage of getPrice()\npublic class Example {\n    public static void main(String[] args) {\n        Order order = new Order(\"John\", 10.99, 1634528700);\n        System.out.println(order.getPrice()); // output: 10.99\n    }\n}\n","description":""},"name":"getPrice","code":"public double getPrice() {\n\t\treturn price;\n\t}","location":{"start":109,"insert":109,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null},{"id":"83958e77-5de0-9780-6541-33cc78a23735","ancestors":["c81f6a40-d51c-0c8d-7948-dee480df477e"],"type":"function","description":"returns the current timestamp value stored in the `timestamp` field.","params":[],"returns":{"type_name":"long","description":"a long value representing the current timestamp.","complex_type":false},"usage":{"language":"java","code":"public class Main {\n\tpublic static void main(String[] args) {\n\t\tOrder order = new Order(\"John\", 100, 1548273697);\n\t\tSystem.out.println(order.getTimestamp());\n\t}\n}\n","description":""},"name":"getTimestamp","code":"public long getTimestamp() {\n\t\treturn timestamp;\n\t}","location":{"start":112,"insert":112,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":3,"docLength":null},{"id":"3f701817-fa3e-f79b-ba4f-a853a0028883","ancestors":["c81f6a40-d51c-0c8d-7948-dee480df477e"],"type":"function","description":"generates a list of `Order` objects based on user input parameters. It creates a random number of users, and for each user, it generates a unique name and adds an order with a randomly generated price and creation time. The resulting list of orders is returned.","params":[{"name":"listLength","type_name":"int","description":"total number of orders to be generated in the function, and it is used to determine the number of users and the size of the list returned by the function.","complex_type":false}],"returns":{"type_name":"ListOrder","description":"a list of `Order` objects, each representing an order with a unique user name, price, and timestamp.\n\n* `List<Order>`: The function returns a list of orders.\n* `Order`: Each element in the list is an instance of the `Order` class, representing a single order.\n* `String userName`: Each order has a unique user name associated with it.\n* `double price`: Each order has a randomly generated price between 1 and 1000.\n* `long timestamp`: Each order has a timestamp in nanoseconds representing when the order was created.","complex_type":true},"name":"genOrders","code":"public static List<Order> genOrders(int listLength){\n\t\tArrayList<Order> list = new ArrayList<>(listLength);\n\t\tRandom rand = new Random();\n\t\tint users = listLength/200;// 200 orders per user\n\t\tusers = users==0 ? listLength : users;\n\t\tArrayList<String> userNames = new ArrayList<>(users);\n\t\tfor(int i=0; i<users; i++){\n\t\t\tuserNames.add(UUID.randomUUID().toString());\n\t\t}\n\t\tfor(int i=0; i<listLength; i++){\n\t\t\tdouble price = rand.nextInt(1000);\n\t\t\tString userName = userNames.get(rand.nextInt(users));\n\t\t\tlist.add(new Order(userName, price, System.nanoTime()));\n\t\t}\n\t\treturn list;\n\t}","location":{"start":115,"insert":115,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":16,"docLength":null},{"id":"b194dc0b-c7d3-bdba-4d49-c8919cbbfc62","ancestors":["c81f6a40-d51c-0c8d-7948-dee480df477e"],"type":"function","description":"generates a string representation of an object by combining the user name and price.","params":[],"returns":{"type_name":"string","description":"a string consisting of the user name followed by a colon and then the price.\n\n* `userName`: A string value representing the user's name.\n* `price`: An integer value representing the price of the item.","complex_type":true},"usage":{"language":"java","code":"public class Order {\n    private String userName;\n    private double price;\n\n    public Order(String userName, double price) {\n        this.userName = userName;\n        this.price = price;\n    }\n\n    @Override\n    public String toString() {\n        return userName + \"::\" + price;\n    }\n}\n","description":"\nHere is how the method would be used:\n"},"name":"toString","code":"@Override\n\tpublic String toString(){\n\t\treturn userName + \"::\" + price;\n\t}","location":{"start":131,"insert":131,"offset":"\t","indent":1,"comment":null},"item_type":"method","length":4,"docLength":null}]}}}